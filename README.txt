The submission consists of the following files whose documentation is provided below:

1. Assignment2Driver.java : This file contains the driver of the assignment. It takes in a file and reads the catalog size, numbers of buyers and sellers, sleep times of buyers and sellers, and then the inventory. For the inventory we put in elements into an ArrayList and tranfer them to a queue of class Queue which is the inventory. Then we define the required locks and conditions for the threads, and the array of sellers and buyers, and the priority queue in which the sellers deposit the items and the buyers take items from. Then using two for loops, we initialise the buyer and the seller threads and start the threads.

2. Bases.java : This file consists of the base classes and interfaces for the Node, Queue, PriorityQueue, Buyer and Seller classes, which is given to us already in the assignment.

3. Buyer.java : This file consists of the Buyer class. The function we had to change was the buy() function. In that, in the try block, I locked the lock, and waited while the catalog is empty. When the catalog is non-empty, the buyer can buy the thing (this is shown in the output) and signal the full condition that we have space in the catalog. In the finally block, we unlock the lock for later usage.

4. Item.java : This file contains the Item class, and for every function other than the constructor, we returned the value that is demanded of us. In the constructor, we initialise the name and price variables to the arguments passed to the function.

5. Node.java : This file contains the Node class, and for every function other than the constructor, we returned the value that is demanded of us. In the constructor, we initialise the priority and value variables to the arguments passed to the function.

6. PriorityQueue.java : This file contains the PriorityQueue class which is used to implement the catalog. In the constructor, we initialise the capacity and currentSize variables, and define the array 'queue' of size equal to the capacity. In the capacity(), size(), isEmpty() and isFull() functions, we return the value of capacity, number of elements in the queue, boolean value corresponding to whether the PriorityQueue is empty or not, and the boolean value corresponding to whether the PriorityQueue is full or not. The priority queue is always sorted in non-increasing order of priority. In the enqueue function, we check if the priority queue is full or not. If it is not, we first search for an index whose priority is less than the priority of the node we want to add. If we have found one like this, we shift all the elements (starting from that one) to the right and put that node there. Else we just append it to the end of the queue.
In the dequeue function, we always remove the last element (since the queue is always sorted in a non-increasing order) and make the value of the element null. The display() function was given to us already.

7. Queue.java : This file contains the Queue class which is used to implement the inventory. In the constructor, we initialise the front, rear, capacity and currentSize variables, and define the array 'queue' of size equal to the capacity. In the capacity(), size(), isEmpty() and isFull() functions, we return the value of capacity, number of elements in the queue, boolean value corresponding to whether the Queue is empty or not, and the boolean value corresponding to whether the Queue is full or not. For my code, front refers to the index of the element in the font, and rear refers to the index of the element after the end of the last added element in the queue (we consider all indices modulo capacity). In the enqueue function, we check if the priority queue is full or not. If it is not, we assign the node to the rear position and add 1 to rear and currentSize. In the dequeue function, we remove the element on the front and add one to front and subtract one from the currentSize and return the removed element.

8. Seller.java : This file consists of the Seller class. The function we had to change was the sell() function. In that, in the try block, I locked the lock, and waited while the catalog is full. When the catalog is non-full, the seller can put the thing in the catalog and signal the empty condition that we have at least one element in the catalog. In the finally block, we unlock the lock for later usage.
